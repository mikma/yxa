diff --git a/configure.ac b/configure.ac
index 3858e7a..bfe1342 100644
--- a/configure.ac
+++ b/configure.ac
@@ -35,6 +35,9 @@ ERLANG_SUBST_LIB_VER(yaws)
 ERLANG_SUBST_LIB_VER(crypto)
 ERLANG_SUBST_LIB_VER(public_key)
 
+AC_CHECK_FILE([${ERLANG_LIB_DIR_public_key}/include/OTP-PUB-KEY.hrl],[HAS_OTP_PUB_KEY_HRL="true"],[HAS_OTP_PUB_KEY_HRL="false"])
+AC_SUBST(HAS_OTP_PUB_KEY_HRL)
+
 AC_CONFIG_FILES(
 		Makefile \
 		src/Makefile \
diff --git a/src/Makefile.in b/src/Makefile.in
index 0638f55..3b6ad26 100644
--- a/src/Makefile.in
+++ b/src/Makefile.in
@@ -41,6 +41,8 @@ ERLANG_LIB_VER_crypto = @ERLANG_LIB_VER_crypto@
 ERLANG_LIB_VER_public_key = @ERLANG_LIB_VER_public_key@
 ERLANG_LIB_VER_SUBST = @ERLANG_LIB_VER_SUBST@
 
+HAS_OTP_PUB_KEY_HRL = @HAS_OTP_PUB_KEY_HRL@
+
 mkinstalldirs = $(SHELL) $(top_srcdir)/scripts/mkinstalldirs
 
 systools_make_script = \
@@ -115,6 +117,7 @@ imported_hrl_FILES = \
 	include/yxa_config.hrl
 
 hrl_FILES = \
+	config.hrl
 
 yxa_hrl_FILES = $(imported_hrl_FILES) $(hrl_FILES)
 
@@ -191,13 +194,14 @@ clean: clean-recursive
 	rm -f $(rel_FILES) start_ssl.rel sys.config
 	rm -f $(app_FILES)
 	rm -f $(beam_FILES)
+	rm -f config.hrl
 
 $(beam_FILES): $(yxa_hrl_FILES)
 $(boot_FILES): $(beam_FILES)
 
-SUFFIXES = .c .o .hrl .beam .erl .boot .rel .rel-in .app .app-in .rel-in
+SUFFIXES = .c .o .hrl .beam .erl .boot .rel .rel-in .app .app-in .rel-in .hrl-in
 .SUFFIXES:
-.SUFFIXES: .c .o .hrl .beam .erl .boot .rel .rel-in .app .app-in .rel-in
+.SUFFIXES: .c .o .hrl .beam .erl .boot .rel .rel-in .app .app-in .rel-in .hrl-in
 
 $(ebin_dir)/%.beam:	$(srcdir)/%.erl
 	$(ERLC) $(L_ERLC_FLAGS) $<
@@ -227,6 +231,10 @@ sys.config:	$(srcdir)/sys.config-in
 start_ssl.boot: $(ebin_dir)/start_ssl.rel
 	$(systools_make_script)
 
+config.hrl: $(srcdir)/config.hrl-in
+	sed -e 's,[@]HAS_OTP_PUB_KEY_HRL[@],$(HAS_OTP_PUB_KEY_HRL),g' \
+	  < $< > $@
+
 test: $(ebin_dir)/autotest.beam
 	$(ERL) -noshell -s autotest run shell -pz $(ebin_dir)
 
diff --git a/src/config.hrl-in b/src/config.hrl-in
new file mode 100644
index 0000000..087c7a6
--- /dev/null
+++ b/src/config.hrl-in
@@ -0,0 +1,3 @@
+%%% Generated automatically by Makefile
+
+-define(HAS_OTP_PUB_KEY_HRL, @HAS_OTP_PUB_KEY_HRL@).
diff --git a/src/transportlayer/Makefile.in b/src/transportlayer/Makefile.in
index 051184c..d768fc1 100644
--- a/src/transportlayer/Makefile.in
+++ b/src/transportlayer/Makefile.in
@@ -47,7 +47,8 @@ erl_FILES = \
 	tcp_dispatcher.erl \
 	tcp_listener.erl \
 	tcp_receiver.erl \
-	transportlayer.erl
+	transportlayer.erl \
+	yxa_ssl_pkix_oid.erl
 
 imported_hrl_FILES = \
 	../include/yxa_config.hrl \
@@ -86,7 +87,7 @@ distclean: clean
 clean:
 	rm -f core *.core *~
 	rm -f *.beam *.script *.start *.boot *.rel *.app *.script
-	rm -f *.o ktrace.out erl_crash.dump
+	rm -f *.o ktrace.out erl_crash.dump yxa_ssl_pkix_oid.erl
 	rm -f $(beam_FILES)
 
 doc:
@@ -106,3 +107,6 @@ SUFFIXES = .c .o .hrl .beam .erl .boot .rel .rel-in .app .app-in
 
 $(ebin_dir)/%.beam:	$(srcdir)/%.erl
 	$(ERLC) $(L_ERLC_FLAGS) $<
+
+yxa_ssl_pkix_oid.erl: $(ebin_dir)/mk_yxa_ssl_pkix_oid.beam
+	$(ERL) -noinput -pa $(ebin_dir) -run mk_yxa_ssl_pkix_oid make -run init stop
diff --git a/src/transportlayer/mk_yxa_ssl_pkix_oid.erl b/src/transportlayer/mk_yxa_ssl_pkix_oid.erl
new file mode 100644
index 0000000..ad62428
--- /dev/null
+++ b/src/transportlayer/mk_yxa_ssl_pkix_oid.erl
@@ -0,0 +1,100 @@
+-module(mk_yxa_ssl_pkix_oid).
+
+-export([make/0]).
+
+-include("config.hrl").
+-ifdef( HAS_OTP_PUB_KEY_HRL ).
+-define(PKIX_MODULES, ['OTP-PUB-KEY']).
+-else.
+-define(PKIX_MODULES, ['OTP-PKIX']).
+-endif.
+
+
+make() ->
+    {ok, Fd} = file:open("yxa_ssl_pkix_oid.erl", [write]),
+    io:fwrite(Fd, "%%% File: yxa_ssl_pkix_oid.erl\n"
+	      "%%% NB This file has been automatically generated by "
+	      "mk_yxa_ssl_pkix_oid.\n"
+	      "%%% Do not edit it.\n\n", []),
+    io:fwrite(Fd, "-module(yxa_ssl_pkix_oid).\n", []),
+    io:fwrite(Fd, "-export([id2atom/1, atom2id/1"
+	      "]).\n\n", []),
+
+
+    AIds0 = get_atom_ids(?PKIX_MODULES),
+
+    AIds1 = modify_atoms(AIds0),
+    gen_id2atom(Fd, AIds1),
+    gen_atom2id(Fd, AIds1),
+    %% gen_all(Fd, AIds1),
+    file:close(Fd).
+
+get_atom_ids(Ms) ->
+    get_atom_ids(Ms, []).
+
+get_atom_ids([], AIdss) ->
+    lists:flatten(AIdss);
+get_atom_ids([M| Ms], AIdss) ->
+    {value, {exports, Exports}} = 
+	lists:keysearch(exports, 1, M:module_info()),
+    As = lists:zf(
+	   fun ({info, 0}) -> false;
+	       ({module_info, 0}) -> false;
+	       ({encoding_rule, 0}) -> false;
+	       ({F, 0}) -> 
+		   case atom_to_list(F) of
+		   %% Remove upper-bound (ub-) functions
+		       "ub-" ++ _Rest ->
+			   false;
+		       _ ->
+			   {true, F}
+		   end;
+	       (_) -> false 
+	   end, Exports),
+    AIds = lists:map(fun(F) -> {F, M:F()} end, As),
+    get_atom_ids(Ms, [AIds| AIdss]).
+
+modify_atoms(AIds) ->
+    F = fun({A, I}) ->
+		NAS = case atom_to_list(A) of
+			  "id-" ++ Rest ->
+			      Rest;
+			  Any ->
+			      Any
+		      end,
+		{list_to_atom(NAS), I} end,
+    lists:map(F, AIds). 
+
+gen_id2atom(Fd, AIds0) ->
+    AIds1 = lists:keysort(2, AIds0),
+    Txt = join(";\n", 
+	       lists:map(
+		 fun({Atom, Id}) ->
+			 io_lib:fwrite("id2atom(~p) ->\n    ~p", [Id, Atom]) 
+		 end, AIds1)),
+    io:fwrite(Fd, "~s;\nid2atom(Any)->\n    Any.\n\n", [Txt]).
+
+gen_atom2id(Fd, AIds0) ->
+    AIds1 = lists:keysort(1, AIds0),
+    Txt = join(";\n", 
+	       lists:map(
+		 fun({Atom, Id}) ->
+			 io_lib:fwrite("atom2id(~p) ->\n    ~p", [Atom, Id]) 
+		 end, AIds1)),
+    io:fwrite(Fd, "~s;\natom2id(Any)->\n    Any.\n\n", [Txt]).
+
+%% gen_all(Fd, AIds) ->
+%%     Atoms = lists:sort([A || {A, _} <- AIds]),
+%%     Ids = lists:sort([I || {_, I} <- AIds]),
+%%     F = fun(X) -> io_lib:fwrite("    ~w", [X]) end,
+%%     ATxt = "all_atoms() ->\n" ++ join(",\n", lists:map(F, Atoms)),
+%%     io:fwrite(Fd, "~s.\n\n", [ATxt]),
+%%     ITxt = "all_ids() ->\n" ++ 	join(",\n", lists:map(F, Ids)),
+%%     io:fwrite(Fd, "~s.\n\n", [ITxt]).
+
+join(Sep, [H1, H2| T]) ->
+    [H1, Sep| join(Sep, [H2| T])]; 
+join(_Sep, [H1]) ->
+    H1;
+join(_, []) ->
+    [].
diff --git a/src/transportlayer/ssl_util.erl b/src/transportlayer/ssl_util.erl
index dde73ab..fe90e40 100644
--- a/src/transportlayer/ssl_util.erl
+++ b/src/transportlayer/ssl_util.erl
@@ -24,7 +24,16 @@
 %%--------------------------------------------------------------------
 %% Include files
 %%--------------------------------------------------------------------
+-include("config.hrl").
+-ifdef( HAS_OTP_PUB_KEY_HRL ).
+-include_lib("public_key/include/OTP-PUB-KEY.hrl").
+-define(PKIX_MODULE, 'OTP-PUB-KEY').
+-define(ATTRIBUTE_TYPE_AND_VALUE, 'OTPAttributeTypeAndValue').
+-else.
 -include_lib("ssl/include/OTP-PKIX.hrl").
+-define(PKIX_MODULE, 'OTP-PKIX').
+-define(ATTRIBUTE_TYPE_AND_VALUE, 'SSLAttributeTypeAndValue').
+-endif.
 -include("sipsocket.hrl").
 
 
@@ -167,7 +176,7 @@ is_acceptable_ssl_socket(Socket, Dir, Proto, Remote, Names) when Proto == tls or
 %%
 %% @doc     Turn a rdnSequence into a list of {Key, Value} where Key
 %%          is either the oid (integer() or tuple()) or, if
-%%          ssl_pkix_oid could turn it into an atom, then an atom
+%%          yxa_ssl_pkix_oid could turn it into an atom, then an atom
 %%          (like countryName).
 %% @end
 %%--------------------------------------------------------------------
@@ -179,7 +188,7 @@ decode_ssl_rdnseq(_Other) ->
 decode_ssl_rdnseq2([[H] | T], Res) when is_record(H, 'AttributeTypeAndValue') ->
     %% get type
     Type =
-	try ssl_pkix_oid:id2atom(H#'AttributeTypeAndValue'.type) of
+	try yxa_ssl_pkix_oid:id2atom(H#'AttributeTypeAndValue'.type) of
 	    A ->
 		A
 	catch
@@ -189,11 +198,11 @@ decode_ssl_rdnseq2([[H] | T], Res) when is_record(H, 'AttributeTypeAndValue') ->
     %% get value - copy-pasted from ssl_pkix:transform/1
     try
 	begin
-	    {ok, ATAVEnc} = 'OTP-PKIX':encode('AttributeTypeAndValue', H),
-	    'OTP-PKIX':decode('SSLAttributeTypeAndValue', list_to_binary(ATAVEnc))
+	    {ok, ATAVEnc} = ?PKIX_MODULE:encode('AttributeTypeAndValue', H),
+	    ?PKIX_MODULE:decode(?ATTRIBUTE_TYPE_AND_VALUE, list_to_binary(ATAVEnc))
 	end of
-	{ok, ATAVDec} when is_record(ATAVDec, 'SSLAttributeTypeAndValue') ->
-	    case ATAVDec#'SSLAttributeTypeAndValue'.value of
+	{ok, ATAVDec} when is_record(ATAVDec, ?ATTRIBUTE_TYPE_AND_VALUE) ->
+	    case ATAVDec#?ATTRIBUTE_TYPE_AND_VALUE.value of
 		{printableString, Value} ->
 		    decode_ssl_rdnseq2(T, [{Type, Value} | Res]);
 		Str when is_list(Str) ->
@@ -278,7 +287,7 @@ ssl_decoded_rdn_get(Key, L) ->
 %%--------------------------------------------------------------------
 get_ssl_peer_info_host_altnames(Cert) when is_record(Cert, 'Certificate') ->
     Extensions = (Cert#'Certificate'.tbsCertificate)#'TBSCertificate'.extensions,
-    AltNameExtensions = get_tbs_extensions(ssl_pkix_oid:atom2id('ce-subjectAltName'), Extensions),
+    AltNameExtensions = get_tbs_extensions(yxa_ssl_pkix_oid:atom2id('ce-subjectAltName'), Extensions),
     {ok, DNS_altNames} = get_host_altnames('SubjectAltName', AltNameExtensions),
     {ok, DNS_altNames}.
 
@@ -300,7 +309,7 @@ get_host_altnames(Type, Extensions) ->
     get_host_altnames(Type, Extensions, []).
 
 get_host_altnames(Type, [#'Extension'{extnValue = Value} | T], Res) ->
-    {ok, Decoded} = 'OTP-PKIX':decode(Type, list_to_binary(Value)),
+    {ok, Decoded} = ?PKIX_MODULE:decode(Type, list_to_binary(Value)),
     %% Decoded is a list of tuples, for example :
     %%   [{rfc822Name, "ft@example.org"},
     %%    {dNSName,    "sip.example.org"}]
